package config

import (
	"fmt"
	"log"
	"os"

	"gopkg.in/yaml.v3"
)

// Config holds all application configuration settings.
type Config struct {
	Common struct {
		NoAck       bool `yaml:"no_ack"`              // If true, disables ACK messages and enables full-speed send
		SendBufSize int  `yaml:"send_buffer_size"`    //overwrite os/kernel tcp buffer
		RecvBufSize int  `yaml:"receive_buffer_size"` // overwrite os/kernel tcp buffer
		AckAfter    int  `yaml:"ack_after"`           // send ack after number of messages
	} `yaml:"common"`

	Server struct {
		FrontendTCPAddress      string `yaml:"frontend_tcp_address"`
		BackendInprocAddress    string `yaml:"backend_inproc_address"`
		NumberOfWorkers         int    `yaml:"number_of_workers"`          // Number of server-side workers/processors
		GeneratedFileNamePrefix string `yaml:"generated_file_name_prefix"` // Prefix for files generated by server workers
		HighWaterMark           int    `yaml:"high_water_mark"`            // Server-specific ZMQ HWM
		NoWrite                 bool   `yaml:"no_write"`
	} `yaml:"server"`

	// // Performance logging configuration
	// PerformanceLog struct {
	// 	Enable            bool   `yaml:"enable"`
	// 	LogDirectoryPath  string `yaml:"log_directory_path"`
	// 	FlushIntervalSecs int    `yaml:"flush_interval_seconds"`
	// } `yaml:"performance_logging"`
}

// AppConfig is the global configuration instance.
var AppConfig Config

// init function is automatically called before main().
// It loads the configuration from "config.yaml" and performs basic validation.
func init() {
	configPath := "config.yaml" // Define your config file path here

	data, err := os.ReadFile(configPath)
	if err != nil {
		log.Fatalf("Fatal: Failed to read config file '%s': %v", configPath, err)
	}

	err = yaml.Unmarshal(data, &AppConfig)
	if err != nil {
		log.Fatalf("Fatal: Failed to unmarshal config data from '%s': %v", configPath, err)
	}

	// Perform validation after unmarshaling
	if err := validateConfig(&AppConfig); err != nil {
		log.Fatalf("Fatal: Configuration validation failed: %v", err)
	}

	log.Printf("Configuration loaded and validated successfully from '%s'.", configPath)
}

// GetConfig provides a way to retrieve the global AppConfig.
func GetConfig() *Config {
	return &AppConfig
}

// validateConfig performs checks on critical configuration values.
func validateConfig(cfg *Config) error {

	// Server settings
	if cfg.Server.FrontendTCPAddress == "" {
		return fmt.Errorf("server.frontend_tcp_address cannot be empty")
	}
	if cfg.Server.BackendInprocAddress == "" {
		return fmt.Errorf("server.backend_inproc_address cannot be empty")
	}
	if cfg.Server.NumberOfWorkers <= 0 {
		return fmt.Errorf("server.number_of_workers must be a positive integer")
	}
	if cfg.Server.GeneratedFileNamePrefix == "" {
		return fmt.Errorf("server.generated_file_name_prefix cannot be empty")
	}

	return nil
}
