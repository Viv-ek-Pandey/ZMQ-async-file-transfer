package config

import (
	"fmt"
	"log"
	"os"

	"gopkg.in/yaml.v3"
)

// Config holds all application configuration settings.
type Config struct {
	Common struct {
		NoAck        bool `yaml:"no_ack"`              // If true, disables ACK messages and enables full-speed send
		SendBufSize  int  `yaml:"send_buffer_size"`    // to overwrite os/kernel tcp buffer
		RecvBufSize  int  `yaml:"receive_buffer_size"` // overwirte os/kernel tcp buffer
		AckAfter     int  `yaml:"ack_after"`           // send ack after number of messages
		TcpFullClear bool `yaml:"tcp_full_clear"`
	} `yaml:"common"`

	Client struct {
		BrokerTCPAddress string `yaml:"broker_tcp_address"`
		ChunkSize        int64  `yaml:"chunk_size"`
		NumberOfWorkers  int    `yaml:"number_of_workers"` // Number of client-side workers/senders
		FilePath         string `yaml:"file_path"`         // Path to the file client sends
		HighWaterMark    int    `yaml:"high_water_mark"`   // Client-specific ZMQ HWM
	} `yaml:"client"`

	// Server struct {
	// 	FrontendTCPAddress      string `yaml:"frontend_tcp_address"`
	// 	BackendInprocAddress    string `yaml:"backend_inproc_address"`
	// 	NumberOfWorkers         int    `yaml:"number_of_workers"`          // Number of server-side workers/processors
	// 	GeneratedFileNamePrefix string `yaml:"generated_file_name_prefix"` // Prefix for files generated by server workers
	// 	HighWaterMark           int    `yaml:"high_water_mark"`            // Server-specific ZMQ HWM
	// } `yaml:"server"`

	// // Performance logging configuration
	// PerformanceLog struct {
	// 	Enable            bool   `yaml:"enable"`
	// 	LogDirectoryPath  string `yaml:"log_directory_path"`
	// 	FlushIntervalSecs int    `yaml:"flush_interval_seconds"`
	// } `yaml:"performance_logging"`
}

// AppConfig is the global configuration instance.
var AppConfig Config

// init function is automatically called before main().
// It loads the configuration from "config.yaml" and performs basic validation.
func init() {
	configPath := "config.yaml" // Define your config file path here

	data, err := os.ReadFile(configPath)
	if err != nil {
		log.Fatalf("Fatal: Failed to read config file '%s': %v", configPath, err)
	}

	err = yaml.Unmarshal(data, &AppConfig)
	if err != nil {
		log.Fatalf("Fatal: Failed to unmarshal config data from '%s': %v", configPath, err)
	}

	// Perform validation after unmarshaling
	if err := validateConfig(&AppConfig); err != nil {
		log.Fatalf("Fatal: Configuration validation failed: %v", err)
	}

	log.Printf("Configuration loaded and validated successfully from '%s'.", configPath)
}

// GetConfig provides a way to retrieve the global AppConfig.
func GetConfig() *Config {
	return &AppConfig
}

// validateConfig performs checks on critical configuration values.
func validateConfig(cfg *Config) error {
	// Client settings
	if cfg.Client.BrokerTCPAddress == "" {
		return fmt.Errorf("client.broker_tcp_address cannot be empty")
	}
	if cfg.Client.ChunkSize <= 0 {
		return fmt.Errorf("client.chunk_size must be a positive integer")
	}
	if cfg.Client.NumberOfWorkers <= 0 {
		return fmt.Errorf("client.number_of_workers must be a positive integer")
	}
	// if cfg.Client.FilePath == "" {
	// 	return fmt.Errorf("client.file_path cannot be empty")
	// } else if _, err := os.Stat(cfg.Client.FilePath); os.IsNotExist(err) {
	// 	return fmt.Errorf("client.file_path '%s' does not exist", cfg.Client.FilePath)
	// }
	if cfg.Client.HighWaterMark < 0 { // HWM can be 0 (infinite)
		return fmt.Errorf("client.high_water_mark must be a non-negative integer (0 for infinite)")
	}

	return nil
}
